#include <franka_pole/franka_model.h>
#include <franka_pole/pseudo_inverse.h>
#include <franka_pole/parameters.h>

#include <pinocchio/parsers/urdf.hpp>
#include <pinocchio/algorithm/joint-configuration.hpp>
#include <pinocchio/algorithm/kinematics.hpp>
#include <pinocchio/algorithm/frames.hpp>
#include <pinocchio/algorithm/rnea.hpp>
#include <pinocchio/algorithm/crba.hpp>
#include <ros/package.h>

franka_pole::FrankaModel::FrankaModel(const Parameters *parameters) :
_parameters(parameters)
{
    //Pinocchio model
    std::string package_path = ros::package::getPath("franka_pole");
    if (_parameters->model == Model::D0) pinocchio::urdf::buildModel(package_path + "/robots/franka_pole.urdf", _model);
    else if (_parameters->model == Model::D1) pinocchio::urdf::buildModel(package_path + "/robots/franka_pole_1D.urdf", _model);
    else if (_parameters->model == Model::D2) pinocchio::urdf::buildModel(package_path + "/robots/franka_pole_2D.urdf", _model);
    else pinocchio::urdf::buildModel(package_path + "/robots/franka_pole_2Db.urdf", _model);
    _data = pinocchio::Data(_model);

    //Checking joints
    //URDF are generated by CMake with default name "panda", so no "parameters.arm_id()"
    for (size_t i = 0; i < 7; i++)
    {
        std::string name = "panda_joint" + std::to_string(i + 1);
        if (!_model.existJointName(name)) throw std::runtime_error("FrankaModel: Joint " + name + " not found");
    }
    for (size_t i = 0; i < 2; i++)
    {
        std::string name = "panda_finger_joint" + std::to_string(i + 1);
        if (!_model.existJointName(name)) throw std::runtime_error("FrankaModel: Joint " + name + " not found");
    }
    if (_parameters->model == Model::D1 || _parameters->model == Model::D2 || _parameters->model == Model::D2b)
    {
        if (!_model.existJointName("panda_pole_joint_x")) throw std::runtime_error("FrankaModel: Joint panda_pole_joint_x not found");
    }
    if (_parameters->model == Model::D2 || _parameters->model == Model::D2b)
    {
        if (!_model.existJointName("panda_pole_joint_y")) throw std::runtime_error("FrankaModel: Joint panda_pole_joint_y not found");
    }
    if (_parameters->model == Model::D1 || _parameters->model == Model::D2 || _parameters->model == Model::D2b)
    {
        if (!_model.existFrame("panda_pole_link_lower")) throw std::runtime_error("FrankaModel: Frame panda_pole_link_lower not found");
        _effector_frame_id = _model.getFrameId("panda_pole_link_lower");
        if (!_model.existFrame("panda_pole_link_upper")) throw std::runtime_error("FrankaModel: Frame panda_pole_link_upper not found");
        _pole_frame_id = _model.getFrameId("panda_pole_link_upper");
    }
    else
    {
        if (!_model.existFrame("panda_hand")) throw std::runtime_error("FrankaModel: Frame panda_hand not found");
        _effector_frame_id = _model.getFrameId("panda_hand");
    }
}

Eigen::Matrix<double, 7, 1> franka_pole::FrankaModel::get_gravity_compensation(const Eigen::Matrix<double, 7, 1> &joint_positions)
{
    if (_parameters->model == Model::D0)
    {
        Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
        q9.segment<7>(0) = joint_positions;
        return pinocchio::computeGeneralizedGravity(_model, _data, q9).segment<7>(0);
    }
    else if (_parameters->model == Model::D1)
    {
        pinocchio::Inertia old_inertias[11];
        for (size_t i = 7; i < 11; i++) { old_inertias[i] = _model.inertias[i]; _model.inertias[i].mass() = 0.0; }
        _model.inertias[7].mass() = 1.46552; /* values taken from panda_arm.urdf.xacro */
        _model.inertias[7].lever() = Eigen::Matrix<double, 3, 1>({0.0017561, 0.0013882, 0.0991564});
        
        Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
        q10.segment<7>(0) = joint_positions;
        Eigen::Matrix<double, 10, 1> torque = pinocchio::computeGeneralizedGravity(_model, _data, q10);

        for (size_t i = 7; i < 11; i++) _model.inertias[i] = old_inertias[i];
        return torque.segment<7>(0);
    }
    else
    {
        pinocchio::Inertia old_inertias[12];
        for (size_t i = 7; i < 12; i++) { old_inertias[i] = _model.inertias[i]; _model.inertias[i].mass() = 0.0; }
        _model.inertias[7].mass() = 1.46552; /* values taken from panda_arm.urdf.xacro */
        _model.inertias[7].lever() = Eigen::Matrix<double, 3, 1>({0.0017561, 0.0013882, 0.0991564});
        
        Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
        q11.segment<7>(0) = joint_positions;
        Eigen::Matrix<double, 11, 1> torque = pinocchio::computeGeneralizedGravity(_model, _data, q11);

        for (size_t i = 7; i < 12; i++) _model.inertias[i] = old_inertias[i];
        return torque.segment<7>(0);
    }
}

Eigen::Matrix<double, 9, 1> franka_pole::FrankaModel::get_gravity9(const Eigen::Matrix<double, 7, 1> &joint_positions)
{
    return Eigen::Matrix<double, 9, 1>::Zero();
}

Eigen::Matrix<double, 10, 1> franka_pole::FrankaModel::get_gravity10(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_positions)
{
    pinocchio::Inertia old_inertias[11];
    for (size_t i = 0; i < 11; i++) { old_inertias[i] = _model.inertias[i]; _model.inertias[i].mass() = 0.0; }
    _model.inertias[7].mass() = old_inertias[7].mass() - 1.46552; /* values taken from panda_arm.urdf.xacro */
    _model.inertias[7].lever() = (old_inertias[7].mass() * old_inertias[7].lever() - Eigen::Matrix<double, 3, 1>({0.0017561, 0.0013882, 0.0991564}) * 1.46552) / _model.inertias[7].mass();

    Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
    q10.segment<7>(0) = joint_positions;
    q10(9) = pole_joint_positions(0);
    Eigen::Matrix<double, 10, 1> torque = pinocchio::computeGeneralizedGravity(_model, _data, q10);

    for (size_t i = 0; i < 11; i++) _model.inertias[i] = old_inertias[i];
    return torque;
}

Eigen::Matrix<double, 11, 1> franka_pole::FrankaModel::get_gravity11(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_positions)
{
    pinocchio::Inertia old_inertias[12];
    for (size_t i = 0; i < 12; i++) { old_inertias[i] = _model.inertias[i]; _model.inertias[i].mass() = 0.0; }
    _model.inertias[7].mass() = old_inertias[7].mass() - 1.46552; /* values taken from panda_arm.urdf.xacro */
    _model.inertias[7].lever() = (old_inertias[7].mass() * old_inertias[7].lever() - Eigen::Matrix<double, 3, 1>({0.0017561, 0.0013882, 0.0991564}) * 1.46552) / _model.inertias[7].mass();

    Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
    q11.segment<7>(0) = joint_positions;
    q11(9) = pole_joint_positions(1);
    q11(10) = pole_joint_positions(0);
    Eigen::Matrix<double, 11, 1> torque = pinocchio::computeGeneralizedGravity(_model, _data, q11);

    for (size_t i = 0; i < 12; i++) _model.inertias[i] = old_inertias[i];
    return torque;
}

Eigen::Matrix<double, 9, 1> franka_pole::FrankaModel::get_coriolis9(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 7, 1> &joint_velocities)
{
    Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
    q9.segment<7>(0) = joint_positions;
    Eigen::Matrix<double, 9, 1> v9 = Eigen::Matrix<double, 9, 1>::Zero();
    v9.segment<7>(0) = joint_velocities;
    return pinocchio::computeCoriolisMatrix(_model, _data, q9, v9) * v9;
}

Eigen::Matrix<double, 10, 1> franka_pole::FrankaModel::get_coriolis10(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 7, 1> &joint_velocities, const Eigen::Matrix<double, 2, 1> &pole_joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_velocities)
{
    Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
    q10.segment<7>(0) = joint_positions;
    q10(9) = pole_joint_positions(0);
    Eigen::Matrix<double, 10, 1> v10 = Eigen::Matrix<double, 10, 1>::Zero();
    v10.segment<7>(0) = joint_velocities;
    v10(9) = pole_joint_velocities(0);
    return pinocchio::computeCoriolisMatrix(_model, _data, q10, v10) * v10;
}

Eigen::Matrix<double, 11, 1> franka_pole::FrankaModel::get_coriolis11(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 7, 1> &joint_velocities, const Eigen::Matrix<double, 2, 1> &pole_joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_velocities)
{
    Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
    q11.segment<7>(0) = joint_positions;
    q11(9) = pole_joint_positions(1);
    q11(10) = pole_joint_positions(0);
    Eigen::Matrix<double, 11, 1> v11 = Eigen::Matrix<double, 11, 1>::Zero();
    v11.segment<7>(0) = joint_velocities;
    v11(9) = pole_joint_positions(1);
    v11(10) = pole_joint_positions(0);
    return pinocchio::computeCoriolisMatrix(_model, _data, q11, v11) * v11;
}

Eigen::Matrix<double, 9, 9> franka_pole::FrankaModel::get_mass_matrix9(const Eigen::Matrix<double, 7, 1> &joint_positions)
{
    Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
    q9.segment<7>(0) = joint_positions;
    Eigen::Matrix<double, 9, 9> result = pinocchio::crba(_model, _data, q9);
    result.triangularView<Eigen::StrictlyLower>() = result.transpose().triangularView<Eigen::StrictlyLower>(); //Maybe I could somehow benefit from it's triangular form, but I don't know how
    return result;
}

Eigen::Matrix<double, 10, 10> franka_pole::FrankaModel::get_mass_matrix10(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_positions)
{
    Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
    q10.segment<7>(0) = joint_positions;
    q10(9) = pole_joint_positions(0);
    Eigen::Matrix<double, 10, 10> result = pinocchio::crba(_model, _data, q10);
    result.triangularView<Eigen::StrictlyLower>() = result.transpose().triangularView<Eigen::StrictlyLower>();
    return result;
}

Eigen::Matrix<double, 11, 11> franka_pole::FrankaModel::get_mass_matrix11(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_positions)
{
    Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
    q11.segment<7>(0) = joint_positions;
    q11(9) = pole_joint_positions(1);
    q11(10) = pole_joint_positions(0);
    Eigen::Matrix<double, 11, 11> result = pinocchio::crba(_model, _data, q11);
    result.triangularView<Eigen::StrictlyLower>() = result.transpose().triangularView<Eigen::StrictlyLower>();
    return result;
}

Eigen::Matrix<double, 6, 7> franka_pole::FrankaModel::get_effector_jacobian(const Eigen::Matrix<double, 7, 1> &joint_positions)
{
    if (_parameters->model == Model::D0)
    {
        Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
        q9.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q9);
    }
    else if (_parameters->model == Model::D1)
    {
        Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
        q10.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q10);
    }
    else
    {
        Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
        q11.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q11);
    }

    //pinocchio's ReferenceFrame::WORLD is not consistent with franka's zeroJacobian
    //This algorithm provides same result as zeroJacobian
    pinocchio::SE3 placement = pinocchio::updateFramePlacement(_model, _data, _effector_frame_id);
    Eigen::Matrix<double, 6, 7> jacobian;
    for (size_t i = 0; i < 7; i++)
    {
        jacobian.block<3, 1>(0, i) = _data.oMi[i+1].rotation_impl().col(2).cross(placement.translation_impl() - _data.oMi[i+1].translation_impl());
        jacobian.block<3, 1>(3, i) = _data.oMi[i+1].rotation_impl().col(2);
    }
    return jacobian;
}

Eigen::Matrix<double, 3, 1> franka_pole::FrankaModel::get_effector_centroidal_acceleration(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 7, 1> &joint_velocities)
{
    if (_parameters->model == Model::D0)
    {
        Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
        q9.segment<7>(0) = joint_positions;
        Eigen::Matrix<double, 9, 1> v9 = Eigen::Matrix<double, 9, 1>::Zero();
        v9.segment<7>(0) = joint_velocities;
        Eigen::Matrix<double, 9, 1> a9 = Eigen::Matrix<double, 9, 1>::Zero();
        pinocchio::forwardKinematics(_model, _data, q9, v9, a9);
    }
    else if (_parameters->model == Model::D1)
    {
        Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
        q10.segment<7>(0) = joint_positions;
        Eigen::Matrix<double, 10, 1> v10 = Eigen::Matrix<double, 10, 1>::Zero();
        v10.segment<7>(0) = joint_velocities;
        Eigen::Matrix<double, 10, 1> a10 = Eigen::Matrix<double, 10, 1>::Zero();
        pinocchio::forwardKinematics(_model, _data, q10, v10, a10);
    }
    else
    {
        Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
        q11.segment<7>(0) = joint_positions;
        Eigen::Matrix<double, 11, 1> v11 = Eigen::Matrix<double, 11, 1>::Zero();
        v11.segment<7>(0) = joint_velocities;
        Eigen::Matrix<double, 11, 1> a11 = Eigen::Matrix<double, 11, 1>::Zero();
        pinocchio::forwardKinematics(_model, _data, q11, v11, a11);
    }
    return pinocchio::updateFramePlacement(_model, _data, _effector_frame_id).rotation_impl() * pinocchio::getFrameClassicalAcceleration(_model, _data, _effector_frame_id).linear_impl();
}

Eigen::Matrix<double, 3, 1> franka_pole::FrankaModel::effector_forward_kinematics(const Eigen::Matrix<double, 7, 1> &joint_positions, Eigen::Quaterniond *effector_orientation)
{
    if (_parameters->model == Model::D0)
    {
        Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
        q9.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q9);
    }
    else if (_parameters->model == Model::D1)
    {
        Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
        q10.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q10);
    }
    else
    {
        Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
        q11.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q11);
    }
    pinocchio::SE3 placement = pinocchio::updateFramePlacement(_model, _data, _effector_frame_id);
    if (effector_orientation != nullptr) *effector_orientation = placement.rotation_impl();
    return placement.translation_impl();
}

Eigen::Matrix<double, 3, 1> franka_pole::FrankaModel::pole_forward_kinematics(const Eigen::Matrix<double, 7, 1> &joint_positions, const Eigen::Matrix<double, 2, 1> &pole_joint_positions, Eigen::Quaterniond *pole_orientation)
{
    if (_parameters->model == Model::D0)
    {
        Eigen::Matrix<double, 9, 1> q9 = Eigen::Matrix<double, 9, 1>::Zero();
        q9.segment<7>(0) = joint_positions;
        pinocchio::forwardKinematics(_model, _data, q9);
    }
    else if (_parameters->model == Model::D1)
    {
        Eigen::Matrix<double, 10, 1> q10 = Eigen::Matrix<double, 10, 1>::Zero();
        q10.segment<7>(0) = joint_positions;
        q10(9) = pole_joint_positions(0);
        pinocchio::forwardKinematics(_model, _data, q10);
    }
    else
    {
        Eigen::Matrix<double, 11, 1> q11 = Eigen::Matrix<double, 11, 1>::Zero();
        q11.segment<7>(0) = joint_positions;
        q11(9) = pole_joint_positions(1);
        q11(10) = pole_joint_positions(0);
        pinocchio::forwardKinematics(_model, _data, q11);
    }
    pinocchio::SE3 placement = pinocchio::updateFramePlacement(_model, _data, _pole_frame_id);
    if (pole_orientation != nullptr) *pole_orientation = placement.rotation_impl();
    return placement.translation_impl();
}

Eigen::Matrix<double, 7, 1> franka_pole::FrankaModel::effector_inverse_kinematics(const Eigen::Matrix<double, 3, 1> &effector_position, const Eigen::Quaterniond &effector_orientation, double joint0, const Eigen::Matrix<double, 7, 1> &hint)
{
    //Constants
    const pinocchio::SE3 goal(effector_orientation, effector_position);
    const double tolerance   = 1e-3;
    const int max_iteration  = 1000;
    const double step        = 5e-1;
    const double damp        = 1e-6;

    if (_parameters->model == Model::D0)
    {
        //Copying hints
        Eigen::Matrix<double, 9, 1> result = Eigen::Matrix<double, 9, 1>::Zero();
        result.segment<7>(0) = hint;
        if (!isnan(joint0)) result(0) = joint0;

        //Loop
        for (size_t i = 0; i < max_iteration; i++)
        {
            pinocchio::forwardKinematics(_model, _data, result);
            pinocchio::SE3 placement = pinocchio::updateFramePlacement(_model, _data, _effector_frame_id);
            pinocchio::SE3 difference = goal.actInv(placement);
            Eigen::Matrix<double, 6, 1> error = pinocchio::log6(difference).toVector();
            if (error.norm() < tolerance) return result.segment<7>(0);
            //Originally it were computeJointJacobian, but computeJointJacobian is inconsistent with absolutely everything else (including computeFrameJacobian)
            Eigen::Matrix<double, 6, 9> jacobian;
            pinocchio::computeFrameJacobian(_model, _data, result, _effector_frame_id, pinocchio::ReferenceFrame::LOCAL, jacobian);
            Eigen::Matrix<double, 6, 6> jacobian2 = jacobian.block<6,7>(0,0) * jacobian.block<6,7>(0,0).transpose();
            jacobian2.diagonal().array() += damp;
            Eigen::Matrix<double, 9, 1> gradient;
            gradient.segment<7>(0) = -jacobian.block<6,7>(0,0).transpose() * jacobian2.llt().solve(error);
            gradient.segment<2>(7) = Eigen::Matrix<double, 2, 1>::Zero();
            result = pinocchio::integrate(_model, result, gradient * step);
            if (!isnan(joint0)) result(0) = joint0;
        }
    }
    else if (_parameters->model == Model::D1)
    {
        //Copying hints
        Eigen::Matrix<double, 10, 1> result = Eigen::Matrix<double, 10, 1>::Zero();
        result.segment<7>(0) = hint;
        if (!isnan(joint0)) result(0) = joint0;

        //Loop
        for (size_t i = 0; i < max_iteration; i++)
        {
            pinocchio::forwardKinematics(_model, _data, result);
            pinocchio::SE3 placement = pinocchio::updateFramePlacement(_model, _data, _effector_frame_id);
            pinocchio::SE3 difference = goal.actInv(placement);
            Eigen::Matrix<double, 6, 1> error = pinocchio::log6(difference).toVector();
            if (error.norm() < tolerance) return result.segment<7>(0);
            Eigen::Matrix<double, 6, 10> jacobian;
            pinocchio::computeFrameJacobian(_model, _data, result, _effector_frame_id, pinocchio::ReferenceFrame::LOCAL, jacobian);
            Eigen::Matrix<double, 6, 6> jacobian2 = jacobian.block<6,7>(0,0) * jacobian.block<6,7>(0,0).transpose();
            jacobian2.diagonal().array() += damp;
            Eigen::Matrix<double, 10, 1> gradient;
            gradient.segment<7>(0) = -jacobian.block<6,7>(0,0).transpose() * jacobian2.llt().solve(error);
            gradient.segment<3>(7) = Eigen::Matrix<double, 3, 1>::Zero();
            result = pinocchio::integrate(_model, result, gradient * step);
            if (!isnan(joint0)) result(0) = joint0;
        }
    }
    else
    {
        //Copying hints
        Eigen::Matrix<double, 11, 1> result = Eigen::Matrix<double, 11, 1>::Zero();
        result.segment<7>(0) = hint;
        if (!isnan(joint0)) result(0) = joint0;

        //Loop
        for (size_t i = 0; i < max_iteration; i++)
        {
            pinocchio::forwardKinematics(_model, _data, result);
            pinocchio::SE3 placement = pinocchio::updateFramePlacement(_model, _data, _effector_frame_id);
            pinocchio::SE3 difference = goal.actInv(placement);
            Eigen::Matrix<double, 6, 1> error = pinocchio::log6(difference).toVector();
            if (error.norm() < tolerance) return result.segment<7>(0);
            Eigen::Matrix<double, 6, 11> jacobian;
            pinocchio::computeFrameJacobian(_model, _data, result, _effector_frame_id, pinocchio::ReferenceFrame::LOCAL, jacobian);
            Eigen::Matrix<double, 6, 6> jacobian2 = jacobian.block<6,7>(0,0) * jacobian.block<6,7>(0,0).transpose();
            jacobian2.diagonal().array() += damp;
            Eigen::Matrix<double, 11, 1> gradient;
            gradient.segment<7>(0) = -jacobian.block<6,7>(0,0).transpose() * jacobian2.llt().solve(error);
            gradient.segment<4>(7) = Eigen::Matrix<double, 4, 1>::Zero();
            result = pinocchio::integrate(_model, result, gradient * step);
            if (!isnan(joint0)) result(0) = joint0;
        }
    }
    throw std::runtime_error("franka_pole::FrankaModel::inverse_kinematics(): Number of iterations exeeded");
}